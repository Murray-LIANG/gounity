// DO NOT EDIT.
// GENERATED by go:generate at 2019-05-20 13:26:16.586938 +0000 UTC.
package gounity

import (
	"fmt"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// Job defines `job` type.
type Job struct {
	Resource

	Id               string            `json:"id"`
	Description      string            `json:"description"`
	State            JobStateEnum      `json:"state"`
	StateChangeTime  string            `json:"stateChangeTime"`
	SubmitTime       string            `json:"submitTime"`
	StartTime        string            `json:"startTime"`
	EndTime          string            `json:"endTime"`
	ElapsedTime      string            `json:"elapsedTime"`
	EstRemainTime    string            `json:"estRemainTime"`
	ProgressPct      uint16            `json:"progressPct"`
	Tasks            []*JobTask        `json:"tasks"`
	ParametersOut    string            `json:"parametersOut"`
	MessageOut       *Message          `json:"messageOut"`
	IsJobCancelable  bool              `json:"isJobCancelable"`
	IsJobCancelled   bool              `json:"isJobCancelled"`
	ClientData       string            `json:"clientData"`
	AffectedResource *AffectedResource `json:"affectedResource"`
}

var (
	typeNameJob   = "job"
	typeFieldsJob = strings.Join([]string{
		"id",
		"description",
		"state",
		"stateChangeTime",
		"submitTime",
		"startTime",
		"endTime",
		"elapsedTime",
		"estRemainTime",
		"progressPct",
		"tasks",
		"parametersOut",
		"messageOut",
		"isJobCancelable",
		"isJobCancelled",
		"clientData",
		"affectedResource",
	}, ",")
)

type JobOperatorGen interface {
	NewJobById(id string) *Job

	GetJobById(id string) (*Job, error)

	GetJobs() ([]*Job, error)

	FillJobs(respEntries []*instanceResp) ([]*Job, error)

	FilterJobs(filter *filter) ([]*Job, error)
}

// NewJobById constructs a `Job` object with id.
func (u *Unity) NewJobById(
	id string,
) *Job {

	return &Job{
		Resource: Resource{
			typeName: typeNameJob, typeFields: typeFieldsJob, Unity: u,
		},
		Id: id,
	}
}

// Refresh updates the info from Unity.
func (r *Job) Refresh() error {

	if r.Id == "" {
		return fmt.Errorf(
			"cannot refresh on job without Id nor Name, resource:%v", r,
		)
	}

	var (
		latest *Job
		err    error
	)

	switch r.Id {

	default:
		if latest, err = r.Unity.GetJobById(r.Id); err != nil {
			return err
		}
		*r = *latest
	}
	return nil
}

// GetJobById retrives the `job` by given its id.
func (u *Unity) GetJobById(
	id string,
) (*Job, error) {

	res := u.NewJobById(id)
	err := u.GetInstanceById(res.typeName, id, res.typeFields, res)
	if err != nil {
		if IsUnityError(err) {
			return nil, err
		}
		return nil, errors.Wrap(err, "get job by id failed")
	}
	return res, nil
}

// GetJobs retrives all `job` objects.
func (u *Unity) GetJobs() ([]*Job, error) {

	return u.FilterJobs(nil)
}

// FilterJobs filters the `job` objects by given filters.
func (u *Unity) FilterJobs(
	filter *filter,
) ([]*Job, error) {

	respEntries, err := u.GetCollection(typeNameJob, typeFieldsJob, filter)
	if err != nil {
		return nil, errors.Wrap(err, "filter job failed")
	}
	res, err := u.FillJobs(respEntries)
	if err != nil {
		return nil, errors.Wrap(err, "fill jobs failed")
	}
	return res, nil
}

// FillJobs generates the `job` objects from collection query response.
func (u *Unity) FillJobs(
	respEntries []*instanceResp,
) ([]*Job, error) {

	resSlice := []*Job{}
	for _, entry := range respEntries {
		res := u.NewJobById("") // empty id for fake `Job` object
		if err := u.unmarshalResource(entry.Content, res); err != nil {
			return nil, errors.Wrap(err, "decode to Job failed")
		}
		resSlice = append(resSlice, res)
	}
	return resSlice, nil
}

// Repr represents a `job` object using its id.
func (r *Job) Repr() *idRepresent {

	log := logrus.WithField("job", r)
	if r.Id == "" {
		log.Info("refreshing job from unity")
		err := r.Refresh()
		if err != nil {
			log.WithError(err).Error("refresh job from unity failed")
			return nil
		}
	}
	return &idRepresent{Id: r.Id}
}
