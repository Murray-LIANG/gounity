// DO NOT EDIT.
// GENERATED by go:generate at 2019-01-01 09:01:44.296908927 +0000 UTC.
package gounity

import (
	"fmt"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// Lun defines `lun` type.
type Lun struct {
	Resource

	Description           string             `json:"description"`
	Health                *Health            `json:"health"`
	HostAccess            []*BlockHostAccess `json:"hostAccess"`
	Id                    string             `json:"id"`
	IsThinEnabled         bool               `json:"isThinEnabled"`
	MetadataSize          uint64             `json:"metadataSize"`
	MetadataSizeAllocated uint64             `json:"metadataSizeAllocated"`
	Name                  string             `json:"name"`
	Pool                  *Pool              `json:"pool"`
	SizeAllocated         uint64             `json:"sizeAllocated"`
	SizeTotal             uint64             `json:"sizeTotal"`
	SizeUsed              uint64             `json:"sizeUsed"`
	SnapCount             uint32             `json:"snapCount"`
	SnapWwn               string             `json:"snapWwn"`
	SnapsSize             uint64             `json:"snapsSize"`
	SnapsSizeAllocated    uint64             `json:"snapsSizeAllocated"`
	StorageResource       *StorageResource   `json:"storageResource"`
	Wwn                   string             `json:"wwn"`
}

var (
	typeNameLun   = "lun"
	typeFieldsLun = strings.Join([]string{
		"description",
		"health",
		"hostAccess",
		"id",
		"isThinEnabled",
		"metadataSize",
		"metadataSizeAllocated",
		"name",
		"pool",
		"sizeAllocated",
		"sizeTotal",
		"sizeUsed",
		"snapCount",
		"snapWwn",
		"snapsSize",
		"snapsSizeAllocated",
		"storageResource",
		"wwn",
	}, ",")
)

type LunOperatorGen interface {
	NewLunById(id string) *Lun

	NewLunByName(name string) *Lun

	GetLunById(id string) (*Lun, error)

	GetLunByName(name string) (*Lun, error)

	GetLuns() ([]*Lun, error)

	FillLuns(respEntries []*instanceResp) ([]*Lun, error)

	FilterLuns(filter *filter) ([]*Lun, error)
}

// NewLunById constructs a `Lun` object with id.
func (u *Unity) NewLunById(
	id string,
) *Lun {

	return &Lun{
		Resource: Resource{
			typeName: typeNameLun, typeFields: typeFieldsLun, Unity: u,
		},
		Id: id,
	}
}

// NewLunByName constructs a `lun` object with name.
func (u *Unity) NewLunByName(
	name string,
) *Lun {

	return &Lun{
		Resource: Resource{
			typeName: typeNameLun, typeFields: typeFieldsLun, Unity: u,
		},
		Name: name,
	}
}

// Refresh updates the info from Unity.
func (r *Lun) Refresh() error {

	if r.Id == "" && r.Name == "" {
		return fmt.Errorf(
			"cannot refresh on lun without Id nor Name, resource:%v", r,
		)
	}

	var (
		latest *Lun
		err    error
	)

	switch r.Id {

	case "":
		if latest, err = r.Unity.GetLunByName(r.Name); err != nil {
			return err
		}
		*r = *latest
	default:
		if latest, err = r.Unity.GetLunById(r.Id); err != nil {
			return err
		}
		*r = *latest
	}
	return nil
}

// GetLunById retrives the `lun` by given its id.
func (u *Unity) GetLunById(
	id string,
) (*Lun, error) {

	res := u.NewLunById(id)
	err := u.GetInstanceById(res.typeName, id, res.typeFields, res)
	if err != nil {
		if IsUnityError(err) {
			return nil, err
		}
		return nil, errors.Wrap(err, "get lun by id failed")
	}
	return res, nil
}

// GetLunByName retrives the `lun` by given its name.
func (u *Unity) GetLunByName(
	name string,
) (*Lun, error) {

	res := u.NewLunByName(name)
	if err := u.GetInstanceByName(res.typeName, name, res.typeFields, res); err != nil {
		return nil, errors.Wrap(err, "get lun by name failed")
	}
	return res, nil
}

// GetLuns retrives all `lun` objects.
func (u *Unity) GetLuns() ([]*Lun, error) {

	return u.FilterLuns(nil)
}

// FilterLuns filters the `lun` objects by given filters.
func (u *Unity) FilterLuns(
	filter *filter,
) ([]*Lun, error) {

	respEntries, err := u.GetCollection(typeNameLun, typeFieldsLun, filter)
	if err != nil {
		return nil, errors.Wrap(err, "filter lun failed")
	}
	res, err := u.FillLuns(respEntries)
	if err != nil {
		return nil, errors.Wrap(err, "fill luns failed")
	}
	return res, nil
}

// FillLuns generates the `lun` objects from collection query response.
func (u *Unity) FillLuns(
	respEntries []*instanceResp,
) ([]*Lun, error) {

	resSlice := []*Lun{}
	for _, entry := range respEntries {
		res := u.NewLunById("") // empty id for fake `Lun` object
		if err := u.unmarshalResource(entry.Content, res); err != nil {
			return nil, errors.Wrap(err, "decode to Lun failed")
		}
		resSlice = append(resSlice, res)
	}
	return resSlice, nil
}

// Repr represents a `lun` object using its id.
func (r *Lun) Repr() *idRepresent {

	log := logrus.WithField("lun", r)
	if r.Id == "" {
		log.Info("refreshing lun from unity")
		err := r.Refresh()
		if err != nil {
			log.WithError(err).Error("refresh lun from unity failed")
			return nil
		}
	}
	return &idRepresent{Id: r.Id}
}

// Delete deletes a lun object.
func (r *Lun) Delete() error {

	log := logrus.WithField("lun", r)
	if r.StorageResource == nil {
		log.Info("refreshing lun from unity")
		err := r.Refresh()
		if err != nil {
			return errors.Wrap(err, "refresh lun from unity failed")
		}
	}

	err := r.Unity.DeleteInstance(typeStorageResource, r.StorageResource.Id)
	if err != nil {
		return errors.Wrap(err, "delete lun from unity failed")
	}
	return nil
}
