// DO NOT EDIT.
// GENERATED by go:generate at 2019-05-15 06:25:01.194464791 +0000 UTC.
package gounity

import (
	"fmt"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

// HostLUN defines `hostLUN` type.
type HostLUN struct {
	Resource

	Id            string          `json:"id"`
	Host          *Host           `json:"host"`
	Type          HostLunTypeEnum `json:"type"`
	Hlu           uint16          `json:"hlu"`
	Lun           *Lun            `json:"lun"`
	IsReadOnly    bool            `json:"isReadOnly"`
	IsDefaultSnap bool            `json:"isDefaultSnap"`
}

var (
	typeNameHostLUN   = "hostLUN"
	typeFieldsHostLUN = strings.Join([]string{
		"id",
		"host",
		"type",
		"hlu",
		"lun",
		"isReadOnly",
		"isDefaultSnap",
	}, ",")
)

type HostLUNOperatorGen interface {
	NewHostLUNById(id string) *HostLUN

	GetHostLUNById(id string) (*HostLUN, error)

	GetHostLUNs() ([]*HostLUN, error)

	FillHostLUNs(respEntries []*instanceResp) ([]*HostLUN, error)

	FilterHostLUNs(filter *filter) ([]*HostLUN, error)
}

// NewHostLUNById constructs a `HostLUN` object with id.
func (u *Unity) NewHostLUNById(
	id string,
) *HostLUN {

	return &HostLUN{
		Resource: Resource{
			typeName: typeNameHostLUN, typeFields: typeFieldsHostLUN, Unity: u,
		},
		Id: id,
	}
}

// Refresh updates the info from Unity.
func (r *HostLUN) Refresh() error {

	if r.Id == "" {
		return fmt.Errorf(
			"cannot refresh on hostLUN without Id nor Name, resource:%v", r,
		)
	}

	var (
		latest *HostLUN
		err    error
	)

	switch r.Id {

	default:
		if latest, err = r.Unity.GetHostLUNById(r.Id); err != nil {
			return err
		}
		*r = *latest
	}
	return nil
}

// GetHostLUNById retrives the `hostLUN` by given its id.
func (u *Unity) GetHostLUNById(
	id string,
) (*HostLUN, error) {

	res := u.NewHostLUNById(id)
	err := u.GetInstanceById(res.typeName, id, res.typeFields, res)
	if err != nil {
		if IsUnityError(err) {
			return nil, err
		}
		return nil, errors.Wrap(err, "get hostLUN by id failed")
	}
	return res, nil
}

// GetHostLUNs retrives all `hostLUN` objects.
func (u *Unity) GetHostLUNs() ([]*HostLUN, error) {

	return u.FilterHostLUNs(nil)
}

// FilterHostLUNs filters the `hostLUN` objects by given filters.
func (u *Unity) FilterHostLUNs(
	filter *filter,
) ([]*HostLUN, error) {

	respEntries, err := u.GetCollection(typeNameHostLUN, typeFieldsHostLUN, filter)
	if err != nil {
		return nil, errors.Wrap(err, "filter hostLUN failed")
	}
	res, err := u.FillHostLUNs(respEntries)
	if err != nil {
		return nil, errors.Wrap(err, "fill hostLUNs failed")
	}
	return res, nil
}

// FillHostLUNs generates the `hostLUN` objects from collection query response.
func (u *Unity) FillHostLUNs(
	respEntries []*instanceResp,
) ([]*HostLUN, error) {

	resSlice := []*HostLUN{}
	for _, entry := range respEntries {
		res := u.NewHostLUNById("") // empty id for fake `HostLUN` object
		if err := u.unmarshalResource(entry.Content, res); err != nil {
			return nil, errors.Wrap(err, "decode to HostLUN failed")
		}
		resSlice = append(resSlice, res)
	}
	return resSlice, nil
}

// Repr represents a `hostLUN` object using its id.
func (r *HostLUN) Repr() *idRepresent {

	log := logrus.WithField("hostLUN", r)
	if r.Id == "" {
		log.Info("refreshing hostLUN from unity")
		err := r.Refresh()
		if err != nil {
			log.WithError(err).Error("refresh hostLUN from unity failed")
			return nil
		}
	}
	return &idRepresent{Id: r.Id}
}
